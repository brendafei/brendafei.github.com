---
title: Hashing
categories: 数据结构
---

资料：《The Art Of Computer Programming (Volume 3)》；《算法导论》第11章-散列表  

[//]: # (计划：)
[//]: # (定义、历史、算法、冲突解决、应用 8h)
[//]: # (一致性哈希 4h)

[//]: # (Time：)
[//]: # (20220406 16:30 - 18:30，21:30 - 24:00)
[//]: # (20220407 21:00 - 24:00)

* toc
{:toc}


# 概述

---

哈希 / 散列。任意长度的输入 -散列函数-> 固定长度的输出。  

**为了解决什么问题**  
在查找中避免来回搜查，通过对参数K做某种算数运算，计算一个函数f(K)，直接得出表中K和相关数据的地址。  

**避免重复值的函数是十分稀有的**  
假设有n个元素要映射到m个地址中，那么存在mn种可能，其中m!种可以对每个元素给出不同的值，因此不产生重复值的占比为 m! / mn。eg. n = 31, m = 41，那么这个占比大概是一千万分之一（生日悖论 birthday paradox，23个人中出现同月日出生的人的概率大概为0.4927，<n=23, m=365>）。且，如果出现元素增减，原先能够避免出现重复值的函数大概率将不再适用，需要重新寻找新的函数。

**允许重复值出现并解决其带来的冲突问题**  
引入hashing / scatter storage，散列 / 分散存储  
so，使用hash table时需考虑两部分：1、散列函数；2、冲突collision解决方法  

> The verb "to hash" means to chop something up or to make a mess out of it; the idea in hashing is to scramble some aspects of the key and to use this partial information as the basis for searching.

平均查找时间：O(1)  
最坏查找时间：O(n)，所有的K都映射到同一个桶，通常好的hash function可以避免这种情况

# 散列函数

---

what is a good hash function? 尽可能的随机，尽可能的均匀，避免冲突或者使冲突次数最小化。  
-> **简单均匀散列**：每个关键字都被等可能地散列到m个槽位中的任何一个，并与其他关键字已散列到那个槽位无关。但是实际一般无法验证。

## *直接寻址表 direct-address table

使用一个数组-直接寻址表，其中的每个位置-槽slot，指向集合中一个关键字为k的元素，如果实际集合中没有关键字为k的元素，则该槽为空槽。  
当关键字的全域U比较小、且没有两个元素具有相同的关键字，可以采用此法，简单有效。如果全域U很大，实际存储的关键字集合K相对U来说可能很小，将浪费大量空间。  

直接寻址表的search, insert, delete操作都为O(1)。

## 除法散列法

**h(k) = k mod m**，m就是槽数
- m的选取：不太接近2的整数幂的素数，通常比较好。eg. 2000个元素，如果可以接受一次不成功的查找需要平均检查3个元素，2000 / 3 = 666.667，那么m可以选701，接近666.667、且不接近2的任何次幂的素数

## 乘法散列法

**h(k) = ⌊m (kA mod 1)⌋**
- 关键字k先乘上一个常数A (0 < A < 1)，提取kA的小数部分，以 kA mod 1 表示
- m乘以上面的小数部分的值，再向下取整。
- m的选取：不是特别关键，一般选择2的某个次幂，2p
- A的选取：Knuth建议A取值为 \(\sqrt{5}-1\)/2 = 0.6180339887…

<img src="/assets/images/hashing-multiply.png" width="400" />


**计算步骤**

- 假设计算机的字长为w位，关键字k正好可以用一个字表示，即，k < 2w
- 选择一个整数s，0 < s < 2w，使得 A = s / 2w
- 那么 kA mod 1 = (k * s / 2w) mod 1
  - k * s是一个2w位的值，可以用 r1 * 2w + r0 表示，r1为高w位，r0为低w位
  - / 2w 就是右移>>w位，此时r0为小数部分
  - mod 1取小数部分，即为r0
- m (kA mod 1)：
  - m = 2p，因此乘以m即为将r0左移<<p位
- 所以h(k)即为r0的高p位


## 全域散列法 universal hashing

不管关键字都有什么，随机的选择散列函数 -> 散列函数独立于要存储的关键字  
- 事先精心设计一组散列函数，实际执行时，从这组函数中随机选择一个

**全域universal的含义**  
使用函数组中随机选择的一个散列函数，两个不相等的关键字发生冲突的概率不大于 1 / m（m还是映射的槽数）
> 意会：也就是说，假设是链接法处理冲突，那么每个链表的长度最大不超过关键字全集长度n/m（实际证明时需区分要散列的关键字k是否已经存在于其对应的链表中，期望的链表长度分别为不存在时n/m和存在时n/m+1，数学证明…不考虑了，意会意会）

**解决什么问题**  
任何一个特定的散列函数都有可能出现关键字全部散列到同一个槽中的最坏情况，要避免这种可能，尽量使得平均性能良好

**设计一个全域散列函数类**
- 选择一个素数p，使得每个关键字k都在 [1, p - 1] 范围内，so，p > m（假定关键字全域大于m）
- 选择两个数a，b，使得a ∈ 集合Zp* {1, 2, …, p-1}，b ∈ 集合Zp {0, 1, 2, …, p-1}
- 定义散列函数
  - **hab(k) = ((ak + b) mod p) mod m**
  - （一次线性变化再加上模p和模m的归约）
- 散列函数簇为
  - **Hpm = {hab: a ∈ Zp*, b ∈ Zp}**，总共包含p(p-1)个散列函数

**证明全域universal**
- 两个不相等的关键字 k ≠ l，计算 r = (ak + b) mod p, s = (al + b) mod p，一定有 r ≠ s
- 因为 r - s ≡ a (k - l) mod p，a和(k - l)模p均不为0，而p为素数，所以乘积模p结果也不为0，so，r ≠ s
- 于是，对于某个给定的r，s的可能取值就位余下的 p - 1 种（模p的结果在[0, p-1]中）
- 而能够满足 s ≠ r 且 s ≡ r mod m 的s数量最多为：
  - p / m - 1 <= ((p + m - 1) / m) - 1 = (p - 1) / m
- so，s和r发生冲突的概率最多为 (p - 1) / m / (p - 1) = 1 / m


## 完全散列 perfect hashing

<br/>
<br/>

# 冲突解决

---

## 链接法 chaining

散列到同一个槽中的所有元素放在一个链表中，散列表中存放指向链表表头的指针。链表最好设计为双向链表，可以使得删除操作时间为O(1)（前提是删除的参数为元素本身而不是其关键字k）。

<mark>装载因子load factor α</mark>：n个元素，m个槽位，α = n / m，即一个链的平均元素数。

查找时间：O(1 + α)，成功查找和失败查找都是这个时间（证明方式不同…）
- **如果散列表中的槽数m和表中的元素n成正比，则有 n = O(m)，从而  α = n / m = O(m) / m = O(1)**

采用双向链表，insert最坏情况也为O(1)，delete最坏情况也为O(1)


## 开放寻址法 open addressing

所有元素直接存放在散列表中，散列表有可能被填满导致不能继续插入新元素。装载因子α绝不会超过1。（？因为设计时一定要考虑表中可以存放下所有的元素，so 槽位m >= 关键字全集个数n）

优点：无需存储指针，直接存储元素，节约空间（从而可以将更多的空间用于槽位，减少冲突）

**探查probe**  
连续检查散列表，找到空槽来放置待插入的关键字
- 散列函数增加一个参数-探查号（从0开始），对于每个关键字k，开放寻址的探查序列 probe sequence为：
  - < h(k, 0), h(k, 1), … h(m - 1) >
  - 探查序列为 {0, 1, …, m - 1} 的一个排列

**均匀散列 uniform hashing**  
每个关键字的探查序列等可能地为 {0, 1, …, m - 1} 的 m! 种排列中的任一种。真正的均匀散列难以实现，只能近似。


**计算探查序列的方法**
- 线性探查 linear probing

- 二次探查 quadratic probing

- 双重散列 double hashing


# 应用

---

Hash table是一种实现associative array的方法


# 历史

---

TAOCP - P547 Hashing - History：  
- 思想首次提出 1953 H. P. Luhn, IBM。内部备忘录中，建议使用拉链，提出了在外部查找中以使用包含一个以上元素的桶为好。  
- 公开文献首次提到 1956 Arnold. I. Dumey, Computers And Automation。第一个提出除以一个素数和使用余数作为散列地址的思想。  
- 首个出版物 1967 H. Hellerman, Digital Computer System Principles（1967年以前hash已经成了键码转换的标准术语，但是一直没有人在出版物中公开使用这一词语）

*书中提到的概念：
- chaining 拉链
- linked linear list 拉链线性表
- internal searching 内部搜索 vs external searching 外部搜索
  - performed on main / primary memory vs performed on secondary memory
- degenerative address 退化地址
- open addressing 开式寻址法
- linear open addressing 线性开式寻址法 1957 P. Ershov (Russia)
- linear probing 线性探查，一类开式寻址法方案
- linear hashing 线性散列
- extendible hashing 可扩充的散列    